<!doctype html><html><head><meta charset=utf-8><title>The Kubernetes Handbook: A Comprehensive guide of 100 Q&A</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel=stylesheet href=https://AceTheOps.com/plugins/slick/slick.css><link rel=stylesheet href=https://AceTheOps.com/plugins/slick/slick-theme.css><link rel=stylesheet href=https://AceTheOps.com/plugins/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=https://AceTheOps.com/plugins/magnafic-popup/magnific-popup.css><link href=https://AceTheOps.com/scss/style.min.css rel=stylesheet><link rel="shortcut icon" href=https://AceTheOps.com/images/favicon.ico type=image/x-icon><link rel=icon href=https://AceTheOps.com/images/favicon.png type=image/x-icon><script async src="https://www.googletagmanager.com/gtag/js?id=G-FCQTR1NVY6"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FCQTR1NVY6")</script></head><body><nav class="navbar navbar-expand-lg fixed-top"><div class=container><a href=https://AceTheOps.com/ class=navbar-brand><img src=https://AceTheOps.com/images/site-navigation/logo.png alt=site-logo></a>
<button type=button class="navbar-toggler collapsed" data-toggle=collapse data-target=#navbarCollapse>
<span class=navbar-toggler-icon></span>
<span class=navbar-toggler-icon></span>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-between" id=navbarCollapse><ul class="nav navbar-nav main-navigation my-0 mx-auto"><li class=nav-item><a href=https://AceTheOps.com/#home class="nav-link text-dark text-sm-center p-2">Home</a></li><li class=nav-item><a href=https://AceTheOps.com/#about class="nav-link text-dark text-sm-center p-2">About</a></li><li class=nav-item><a href=https://AceTheOps.com/#service class="nav-link text-dark text-sm-center p-2">Service</a></li><li class=nav-item><a href=https://AceTheOps.com/#portfolio class="nav-link text-dark text-sm-center p-2">Work</a></li><li class=nav-item><a href=https://AceTheOps.com/#resume class="nav-link text-dark text-sm-center p-2">Resume</a></li><li class=nav-item><a href=https://AceTheOps.com/#skills class="nav-link text-dark text-sm-center p-2">Skills</a></li><li class=nav-item><a href=https://AceTheOps.com/#contact class="nav-link text-dark text-sm-center p-2">Contact</a></li></ul><div class=navbar-nav><a href=https://AceTheOps.com/blog class="btn btn-primary btn-zoom hire_button">Blog</a></div></div></div></nav><div id=content><header class=breadCrumb><div class=container><div class=row><div class="col-lg-10 col-md-12 offset-lg-1 offset-md-0 text-center"><h3 class=breadCrumb__title>The Kubernetes Handbook: A Comprehensive guide of 100 Q&A</h3><nav aria-label=breadcrumb class="d-flex justify-content-center"><ol class="breadcrumb align-items-center"><li class=breadcrumb-item><a href=https://AceTheOps.com/>Home</a></li><li class=breadcrumb-item><a href=https://AceTheOps.com/blog>All Post</a></li><li class="breadcrumb-item active" aria-current=page>The Kubernetes Handbook: A Comprehensive guide of 100 Q&A</li></ol></nav></div></div><ul class=post-meta><li><i class="fa fa-calendar"></i>
December 25, 2022</li><li><i class="fa fa-clock-o"></i>
24 mins read</li><li><i class="fa fa-tag"></i>
<a class=text-capitalize href=https://AceTheOps.com/tags/faq/>faq</a>
<a class=text-capitalize href=https://AceTheOps.com/tags/cloud_agnostic/>Cloud_Agnostic</a>
<a class=text-capitalize href=https://AceTheOps.com/tags/certification/>certification</a>
<a class=text-capitalize href=https://AceTheOps.com/tags/kubernetes/>kubernetes</a>
<a class=text-capitalize href=https://AceTheOps.com/tags/docker/>docker</a></li><li><i class="fa fa-folder-open"></i>
<a class=text-capitalize href=https://AceTheOps.com/categories/blog/>blog</a></li></ul></div></div></div></div></header><section class="section singleBlog"><div class=svg-img><img src=https://AceTheOps.com/images/hero/figure-svg.svg alt></div><div class=animate-shape><img src=https://AceTheOps.com/images/skill/skill-background-shape.svg alt><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 600 600"><defs><linearGradient id="d" x1=".929" y1=".111" x2=".263" y2=".935" gradientUnits="objectBoundingBox"><stop offset="0" stop-color="#f1f6f9"/><stop offset="1" stop-color="#f1f6f9" stop-opacity="0"/></linearGradient></defs><g data-name="blob-shape (3)"><path class="blob" fill="url(#d)" d="M455.4 151.1c43.1 36.7 73.4 92.8 60.8 136.3-12.7 43.5-68.1 74.4-111.3 119.4-43.1 45-74 104.1-109.8 109-35.9 5-76.7-44.2-111.8-89.2-35.2-45-64.7-85.8-70.8-132.6-6-46.8 11.6-99.6 46.7-136.3 35.2-36.6 88-57.2 142.4-58.8 54.5-1.7 110.6 15.6 153.8 52.2z"/></g></svg></div><div class=animate-pattern><img src=https://AceTheOps.com/images/service/background-pattern.svg alt=background-shape></div><div class=container><div class=row><div class=col-lg-12><div class=singleBlog__feature><img src=https://AceTheOps.com/ alt=feature-image></div></div></div><div class="row mt-5"><div class=col-lg-12><div class=singleBlog__content><h2 id=here-are-100-questions-that-could-potentially-be-asked-on-a-kubernetes-exam-or-as-part-of-a-technical-interview>Here are 100 questions that could potentially be asked on a Kubernetes exam or as part of a technical interview:</h2><ol><li>What is Kubernetes?</li><li>What are the main components of a Kubernetes cluster?</li><li>What is a pod in Kubernetes?</li><li>What is a node in Kubernetes?</li><li>What is a cluster in Kubernetes?</li><li>What is the Kubernetes API used for?</li><li>What is kubectl used for?</li><li>What is a Deployment in Kubernetes?</li><li>What is Helm used for?</li><li>How does a Deployment ensure that a specified number of replicas of a pod are always running?</li><li>What is a ReplicationController in Kubernetes?</li><li>What is a Service in Kubernetes?</li><li>What is an Ingress in Kubernetes?</li><li>What is a Volume in Kubernetes?</li><li>What is a PersistentVolume in Kubernetes?</li><li>What is a PersistentVolumeClaim in Kubernetes?</li><li>What is a ConfigMap in Kubernetes?</li><li>What is a Secret in Kubernetes?</li><li>What is a StatefulSet in Kubernetes?</li><li>What is a DaemonSet in Kubernetes?</li><li>What is a Job in Kubernetes?</li><li>What is a CronJob in Kubernetes?</li><li>What is a Namespace in Kubernetes?</li><li>What is a Label in Kubernetes?</li><li>What is an Annotation in Kubernetes?</li><li>What is a Selector in Kubernetes?</li><li>What is a Label Selector in Kubernetes?</li><li>What is a ResourceQuota in Kubernetes?</li><li>What is a LimitRange in Kubernetes?</li><li>What is a PodDisruptionBudget in Kubernetes?</li><li>What is a Role in Kubernetes?</li><li>What is a ClusterRole in Kubernetes?</li><li>What is a RoleBinding in Kubernetes?</li><li>What is a ClusterRoleBinding in Kubernetes?</li><li>What is a ServiceAccount in Kubernetes?</li><li>What is a PodSecurityPolicy in Kubernetes?</li><li>What is RBAC in Kubernetes?</li><li>What is a Horizontal Pod Autoscaler in Kubernetes?</li><li>What is a Vertical Pod Autoscaler in Kubernetes?</li><li>What is a Cluster Autoscaler in Kubernetes?</li><li>What is a DeploymentRollback in Kubernetes?</li><li>What is a DeploymentStrategy in Kubernetes?</li><li>What is a DeploymentTrigger in Kubernetes?</li><li>What is a DeploymentSpec in Kubernetes?</li><li>What is a DeploymentStatus in Kubernetes?</li><li>What is a DeploymentCondition in Kubernetes?</li><li>What is a DeploymentRollback in Kubernetes?</li><li>What is a DeploymentHistory in Kubernetes?</li><li>What is a DeploymentStrategy in Kubernetes?</li><li>What is a DeploymentTrigger in Kubernetes?</li><li>What is a DeploymentSpec in Kubernetes?</li><li>What is a DeploymentSpec in Kubernetes?</li><li>What is a DeploymentStatus in Kubernetes?</li><li>What is a DeploymentCondition in Kubernetes?</li><li>What is a DeploymentRollback in Kubernetes?</li><li>What is a DeploymentHistory in Kubernetes?</li><li>What is a DeploymentStrategy in Kubernetes?</li><li>What is a DeploymentTrigger in Kubernetes?</li><li>What is a PodSpec in Kubernetes?</li><li>What is a PodStatus in Kubernetes?</li><li>What is a PodCondition in Kubernetes?</li><li>What is a PodContainerStatus in Kubernetes?</li><li>What is a PodEvent in Kubernetes?</li><li>What is a PodIP in Kubernetes?</li><li>What is a PodTemplateSpec in Kubernetes?</li><li>What is a ReplicationControllerSpec in Kubernetes?</li><li>What is a ReplicationControllerStatus in Kubernetes?</li><li>What is a ReplicationControllerCondition in Kubernetes?</li><li>What is a ServiceSpec in Kubernetes?</li><li>What is a ServiceStatus in Kubernetes?</li><li>What is a ServicePort in Kubernetes?</li><li>What is an EndpointSubset in Kubernetes?</li><li>What is an EndpointPort in Kubernetes?</li><li>What is an EndpointAddress in Kubernetes?</li><li>What is an IngressSpec in Kubernetes?</li><li>What is an IngressStatus in Kubernetes?</li><li>What is an IngressRule in Kubernetes?</li><li>What is an IngressPath in Kubernetes?</li><li>What is an IngressBackend in Kubernetes?</li><li>What is a VolumeMount in Kubernetes?</li><li>What is a PersistentVolumeSpec in Kubernetes?</li><li>What is a PersistentVolumeStatus in Kubernetes?</li><li>What is a PersistentVolumeClaimSpec in Kubernetes?</li><li>What is a PersistentVolumeClaimStatus in Kubernetes?</li><li>What is a ConfigMapVolumeSource in Kubernetes?</li><li>What is a SecretVolumeSource in Kubernetes?</li><li>What is a StatefulSetSpec in Kubernetes?</li><li>What is a StatefulSetStatus in Kubernetes?</li><li>What is a StatefulSetVolumeClaim in Kubernetes?</li><li>What is a DaemonSetSpec in Kubernetes?</li><li>What is a DaemonSetStatus in Kubernetes?</li><li>What is a JobSpec in Kubernetes?</li><li>What is a JobStatus in Kubernetes?</li><li>What is a JobCondition in Kubernetes?</li><li>What is a CronJobSpec in Kubernetes?</li><li>What is a CronJobStatus in Kubernetes?</li><li>What is a CronJobSuspend in Kubernetes?</li><li>What is a CronJobSchedule in Kubernetes?</li><li>What is a CronJobConcurrencyPolicy in Kubernetes?</li><li>What is a CronJobStartingDeadlineSeconds in Kubernetes?</li><li>What is a CronJobSuccessfulJobsHistoryLimit in Kubernetes?</li></ol><h2 id=answers>Answers</h2><p>Q1. What is Kubernetes ?</p><p>Ans. Kubernetes (also known as K8s) is an open-source system for automating the deployment, scaling, and management of containerized applications. It groups containers that make up an application into logical units for easy management and discovery. Kubernetes is designed to handle the complete lifecycle of a containerized application, including deployment, scaling, and management. It is widely used in cloud computing environments and is becoming increasingly popular in on-premises environments as well.</p><p>Kubernetes is designed to be flexible and extensible, so it can be used to manage a wide range of workloads, including microservices, batch jobs, and stateful applications. It is also designed to be highly available, so it can recover from failures and continue to operate even when there are issues with individual nodes in the cluster.</p><p>Kubernetes is managed using a command-line interface (CLI) or through a web-based user interface (UI). It can be deployed on a variety of platforms, including on-premises servers, public cloud providers, and hybrid cloud environments.</p><p>Q2. What are the main components of a Kubernetes cluster?</p><p>Ans. A Kubernetes cluster consists of a set of worker machines, called nodes, that run containerized applications. The nodes communicate with each other through a network to coordinate the deployment and scaling of applications.</p><p>There are several main components of a Kubernetes cluster:</p><ul><li><p>Master node: This is the central control plane of the cluster, which is responsible for managing the state of the cluster and responding to API requests. The master node runs a number of components, including the API server, scheduler, and etcd (a distributed key-value store).</p></li><li><p>Worker nodes: These are the machines that run the containerized applications. Each worker node runs a container runtime (such as Docker), as well as the Kubernetes kubelet and kube-proxy components, which are responsible for communicating with the master node and managing containers on the node.</p></li><li><p>Pods: These are the smallest deployable units in Kubernetes. A pod is a group of one or more containers that are deployed together on the same node. Pods are the basic building blocks of a Kubernetes application and are used to host containerized applications.</p></li><li><p>Services: These provide a stable network endpoint for accessing a group of pods. Services can be used to expose a group of pods to other parts of the cluster or to external users.</p></li><li><p>Deployments: These are used to manage the lifecycle of a group of replicas of a pod. Deployments can be used to create, update, and scale pods in a declarative manner.</p></li><li><p>Ingress: This is a way to expose a service to external users. An ingress can be used to route traffic to a service based on the hostname or path of the incoming request.</p></li></ul><p>There are many other components and features in Kubernetes, including persistent volumes, secrets, and namespaces, which can be used to further organize and manage applications in the cluster.</p><p>Q3. What is a pod in Kubernetes?</p><p>Ans. In Kubernetes, a pod is the basic unit of deployment. It is a group of one or more containers that are deployed together on the same worker node. Pods are used to host containerized applications in Kubernetes.</p><p>Each pod is assigned a unique IP address within the cluster, and containers within the pod can communicate with each other using localhost. Pods are also assigned a hostname, which is derived from the name of the pod.</p><p>Pods are designed to be ephemeral, meaning that they are not intended to be long-lived. If a pod fails or is deleted, it is expected that it will be replaced by a new pod. This design allows for flexibility and resilience in the cluster, as it allows applications to recover from failures quickly.</p><p>Pods are typically managed using higher-level abstractions such as deployments or replicasets, which allow you to declaratively specify the desired state of a group of pods.</p><p>Q4. What is a node in Kubernetes?
Ans. In Kubernetes, a node is a worker machine that runs containerized applications. Nodes are the machines that host the pods that make up an application.</p><p>Each node runs a number of components, including a container runtime (such as Docker), the Kubernetes kubelet and kube-proxy processes, and other supporting utilities. The kubelet is responsible for communicating with the Kubernetes master node and managing the containers on the node. The kube-proxy is a network proxy that runs on each node and is responsible for routing traffic to the correct pods.</p><p>Nodes can be physical machines or virtual machines, depending on the deployment environment. In a cloud environment, nodes are often virtual machines that are created and managed by the cloud provider. In an on-premises environment, nodes can be physical servers or virtual machines running on a hypervisor.</p><p>The nodes in a Kubernetes cluster communicate with each other through a network to coordinate the deployment and scaling of applications. The master node is responsible for managing the state of the cluster and responding to API requests, while the worker nodes run the containerized applications.</p><p>Q5. What is a cluster in Kubernetes?</p><p>Ans. In Kubernetes, a cluster is a set of worker machines, called nodes, that run containerized applications. The nodes communicate with each other through a network to coordinate the deployment and scaling of applications.</p><p>A Kubernetes cluster typically consists of a single master node and one or more worker nodes. The master node is the central control plane of the cluster and is responsible for managing the state of the cluster and responding to API requests. The worker nodes are the machines that run the containerized applications.</p><p>A Kubernetes cluster can be deployed on a variety of platforms, including on-premises servers, public cloud providers, and hybrid cloud environments. It can be managed using a command-line interface (CLI) or through a web-based user interface (UI).</p><p>Q6. What is the Kubernetes API used for
Ans. The Kubernetes API is the primary way that users interact with a Kubernetes cluster. It is a RESTful API that exposes a number of endpoints for creating, modifying, and deleting Kubernetes resources such as pods, services, and deployments.</p><p>The API is implemented by the API server, which is a core component of the Kubernetes master node. The API server is responsible for handling API requests and updating the cluster&rsquo;s state based on those requests.</p><p>The Kubernetes API can be accessed using a variety of tools, including the kubectl command-line interface (CLI), the Kubernetes web-based user interface (UI), and programmatic clients.</p><p>The Kubernetes API is used for a variety of purposes, including:</p><p>Deploying and managing containerized applications in the cluster
Scaling the number of replicas of an application
Updating the configuration of an application
Monitoring the status of an application
Performing rolling updates of an application
The Kubernetes API is an essential part of the Kubernetes system, as it allows users to declaratively specify the desired state of their applications and allows the cluster to automatically reconcile the actual state of the system with the desired state.</p><p>Q7. What is kubectl used for?</p><p>Ans. kubectl is the command-line interface (CLI) for interacting with a Kubernetes cluster. It is used to deploy, manage, and troubleshoot containerized applications in a Kubernetes cluster.</p><p>kubectl is a tool that communicates with the Kubernetes API server to manipulate the desired state of a cluster. It can be used to create, delete, and update resources such as pods, services, and deployments. It can also be used to view the current state of the cluster and to troubleshoot issues.</p><p>kubectl is a powerful tool that allows you to manage your Kubernetes cluster and applications from the command line. It is an essential tool for anyone working with Kubernetes and is often used in conjunction with other tools such as Helm (a package manager for Kubernetes) and Skaffold (a tool for developing and deploying applications to Kubernetes).</p><p>Q8. What is a Deployment in Kubernetes?</p><p>Ans. n Kubernetes, a Deployment is a resource that manages a replicated application. It ensures that a specified number of replicas of a Pod are running at any given time. A Deployment is responsible for creating and updating replicas of your application. It does this by creating and managing ReplicaSets, which are responsible for creating and managing individual Pods.</p><p>Here is an example of a Deployment in YAML format:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-app</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-app:latest</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>In this example, the Deployment creates and manages three replicas of the my-app Pod. The Pod template specifies the container image and port for the application. The Deployment uses a ReplicaSet to ensure that the specified number of replicas is running at all times, and it can also be used to perform rolling updates to the application.</p><p>Q9. What is Helm used for?</p><p>Ans. A helm in Kubernetes is a package manager that helps you install, upgrade, and manage applications on your Kubernetes cluster. It uses &ldquo;charts&rdquo;, which are pre-configured packages of Kubernetes resources, to define and deploy applications.</p><p>For example, to install an NGINX web server using Helm, you can use the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ helm install nginx stable/nginx-ingress
</span></span></code></pre></div><p>This will install the NGINX chart from the &ldquo;stable&rdquo; repository and create all the necessary Kubernetes resources, such as Deployments, Services, and Ingress objects, to run the NGINX web server.</p><p>You can also customize the chart by passing in additional parameters, such as the number of replicas or the image tag to use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ helm install nginx stable/nginx-ingress --set replicas<span style=color:#f92672>=</span>2,image.tag<span style=color:#f92672>=</span>1.17.6
</span></span></code></pre></div><p>This will create a Deployment with 2 replicas of the NGINX web server, using the specified image tag.</p><p>Q10. How does a Deployment ensure that a specified number of replicas of a pod are always running?</p><p>Ans. In Kubernetes, a Deployment is a resource that manages a set of replicas of a pod. It ensures that a specified number of replicas of the pod are always running by creating and deleting pods as needed.</p><p>For example, let&rsquo;s say you have a Deployment with a replicaset of 3 pods running an NGINX web server. If one of the pods goes down due to an error or a node failure, the Deployment will automatically create a new pod to replace it, ensuring that there are always 3 replicas running.</p><p>You can specify the number of replicas in the Deployment configuration file, as well as other details such as the pod template, labels, and readiness probes. Here&rsquo;s an example Deployment configuration file that creates 3 replicas of an NGINX pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><p>To create this Deployment, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f deployment.yaml
</span></span></code></pre></div><p>This will create 3 replicas of the NGINX pod, which will be automatically managed by the Deployment. If any of the pods goes down, the Deployment will create a new one to replace it, ensuring that there are always 3 replicas running.</p><p>Q11. What is a ReplicationController in Kubernetes?</p><p>Ans. A ReplicationController in Kubernetes is a resource that manages a set of replicas of a pod. It ensures that a specified number of replicas of the pod are always running by creating and deleting pods as needed.</p><p>The ReplicationController uses a label selector to determine which pods to manage. If a pod is deleted or goes down, the ReplicationController will create a new one to replace it. If there are too many replicas, it will delete excess pods to bring the number back to the desired value.</p><p>Here&rsquo;s an example ReplicationController configuration file that creates 3 replicas of an NGINX pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicationController</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-rc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span></code></pre></div><p>To create this ReplicationController, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f replicationcontroller.yaml
</span></span></code></pre></div><p>This will create 3 replicas of the NGINX pod, which will be automatically managed by the ReplicationController. If any of the pods goes down, the ReplicationController will create a new one to replace it, ensuring that there are always 3 replicas running.</p><p>Note: ReplicationControllers have been deprecated in Kubernetes and are replaced by Deployments. It is recommended to use Deployments instead of ReplicationControllers.</p><p>Q12. What is a Service in Kubernetes?
Ans. In Kubernetes, a Service is a resource that allows you to access a group of pods by a stable network endpoint. It acts as a load balancer, routing traffic to the appropriate pods based on the service&rsquo;s configuration.</p><p>There are several types of Services in Kubernetes, each with a different purpose. Some common types include:</p><ul><li>ClusterIP: Exposes the Service on a cluster-internal IP, which is only accessible from within the cluster.</li><li>NodePort: Exposes the Service on a specific port on each node in the cluster, allowing external traffic to access the Service.</li><li>LoadBalancer: Exposes the Service on an external load balancer, provided by the cloud provider.</li><li>ExternalName: Maps the Service to an external DNS name, rather than to a set of pods.</li></ul><p>Here&rsquo;s an example Service configuration file that creates a ClusterIP Service for a Deployment of NGINX pods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>app</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>ClusterIP</span>
</span></span></code></pre></div><p>To create this Service, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f service.yaml
</span></span></code></pre></div><p>This will create a Service that routes traffic to the NGINX pods based on the selector specified in the Service configuration. The Service will be accessible from within the cluster on a cluster-internal IP, but not from outside the cluster.</p><p>You can also customize the Service by specifying different ports or types, such as NodePort or LoadBalancer, depending on your needs.</p><p>Q13. What is an Ingress in Kubernetes?</p><p>Ans. In Kubernetes, an Ingress is a resource that allows you to expose your application to the outside world. It acts as a reverse proxy, routing incoming traffic to the appropriate service based on the hostname and path.</p><p>An Ingress can be configured with rules that specify which service to route traffic to based on the hostname and path of the incoming request. It can also be configured with TLS certificates and other options, such as rate limiting or authentication.</p><p>Here&rsquo;s an example Ingress configuration file that routes traffic to an NGINX service based on the hostname:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1beta1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-ingress</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>nginx.ingress.kubernetes.io/ssl-redirect</span>: <span style=color:#e6db74>&#34;false&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>example.com</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>servicePort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>To create this Ingress, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f ingress.yaml
</span></span></code></pre></div><p>This will create an Ingress resource that routes traffic to the NGINX service based on the hostname. If a user accesses the website at &ldquo;example.com&rdquo;, the Ingress will route the request to the NGINX service.</p><p>You can also use Helm to install an Ingress resource. For example, to install an NGINX Ingress controller using Helm, you can use the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ helm install nginx stable/nginx-ingress
</span></span></code></pre></div><p>This will install the NGINX Ingress chart from the &ldquo;stable&rdquo; repository and create all the necessary Kubernetes resources, such as Deployments, Services, and Ingress objects, to run the NGINX Ingress controller.</p><p>Q14. What is a Volume in Kubernetes?</p><p>Ans. A volume in Kubernetes is a way to persist data in a pod beyond the lifetime of the pod. It allows you to store data in a shared storage location that can be accessed by multiple containers within the same pod.</p><p>There are several types of volumes that can be used in Kubernetes, such as hostPath, emptyDir, configMap, secret, and many more.</p><p>For example, you can use an emptyDir volume to create a temporary storage location within the pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>temp-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/tmp/data</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>temp-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>emptyDir</span>: {}
</span></span></code></pre></div><p>This will create a volume called &ldquo;temp-volume&rdquo; that is mounted at the &ldquo;/tmp/data&rdquo; path within the pod. Any data written to this location will be persisted in the volume and will be available to all containers within the pod.</p><p>You can also use a hostPath volume to mount a directory from the host node&rsquo;s filesystem into the pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>host-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/www/html</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>host-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/var/www/html</span>
</span></span></code></pre></div><p>This will create a volume called &ldquo;host-volume&rdquo; that is mounted at the &ldquo;/var/www/html&rdquo; path within the pod, and is backed by the host node&rsquo;s filesystem at the same location.
Any data written to this location will be persisted in the host node&rsquo;s filesystem and will be available to all containers within the pod.</p><p>Q15. What is a PersistentVolume in Kubernetes?</p><p>Ans. A PersistentVolume (PV) in Kubernetes is a piece of storage that has been provisioned for use by pods. It provides a way to persist data in a pod beyond the lifetime of the pod, allowing it to be reused by other pods or even across different deployments.</p><p>PVs can be backed by different types of storage, such as local disks, network-attached storage (NAS), or cloud-based storage solutions like Amazon S3 or Google Cloud Storage.</p><p>To create a PV in Kubernetes, you can use a PersistentVolumeClaim (PVC) resource. The PVC specifies the desired size and type of storage, as well as any other relevant details such as access modes and labels. The PV is then created based on the PVC&rsquo;s specifications and bound to it.</p><p>Here&rsquo;s an example PVC configuration file that creates a PV with 1GB of storage and the &ldquo;ReadWriteOnce&rdquo; access mode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pvc-1gb</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span>
</span></span></code></pre></div><p>To create this PVC, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f pvc.yaml
</span></span></code></pre></div><p>This will create a PV with 1GB of storage and bind it to the PVC. You can then use the PVC in a pod to mount the PV as a volume, allowing the pod to access the persistent storage.</p><p>For example, to use the PVC in an NGINX pod, you can add a volume and volume mount to the pod&rsquo;s configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pvc</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/www/html</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>pvc</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>persistentVolumeClaim</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>pvc-1gb</span>
</span></span></code></pre></div><p>This will mount the PV at the /var/www/html path in the NGINX container, allowing it to access the persistent storage.</p><p>Q16. What is a PersistentVolumeClaim in Kubernetes?</p><p>Ans. In Kubernetes, a PersistentVolumeClaim (PVC) is a resource that allows a pod to request and use persistent storage. It is used to claim a specific amount of storage from a PersistentVolume (PV), which is a piece of storage that has been provisioned in the cluster.</p><p>A PVC consists of a request for a specific amount of storage, as well as the access mode (e.g. read-write or read-only). When a pod requests a PVC, the Kubernetes scheduler will bind the PVC to a PV that meets the requested requirements.</p><p>Here&rsquo;s an example PVC configuration file that requests 1GB of read-write storage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PersistentVolumeClaim</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-pvc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>accessModes</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ReadWriteOnce</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>1Gi</span>
</span></span></code></pre></div><p>To create this PVC, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#ae81ff>$ kubectl apply -f pvc.yaml</span>
</span></span></code></pre></div><p>Once the PVC is created, you can mount it as a volume in a pod. Here&rsquo;s an example pod configuration file that uses the PVC as a volume:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.17.6</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-storage</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/usr/share/nginx/html</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>persistentVolumeClaim</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>claimName</span>: <span style=color:#ae81ff>nginx-pvc</span>
</span></span></code></pre></div><p>To create this pod, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#ae81ff>$ kubectl apply -f pod.yaml</span>
</span></span></code></pre></div><p>This will create a pod with the NGINX web server, using the PVC as the volume for the web content. The persistent storage provided by the PVC will ensure that the web content is preserved even if the pod is deleted or restarted.</p><p>Q17. What is a ConfigMap in Kubernetes?</p><p>Ans. A ConfigMap in Kubernetes is a resource that stores configuration data as key-value pairs. It can be used to store configuration data for applications, such as database credentials, API keys, and other settings.</p><p>ConfigMaps are useful because they allow you to store configuration data in a central location and reference it from multiple places in your Kubernetes cluster, such as pods, Deployments, and Services. This makes it easier to manage and update configuration data, as you only have to change it in one place.</p><p>To create a ConfigMap, you can use the kubectl command and specify the key-value pairs in a configuration file, like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ConfigMap</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-config-map</span>
</span></span><span style=display:flex><span><span style=color:#f92672>data</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>key1</span>: <span style=color:#ae81ff>value1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>key2</span>: <span style=color:#ae81ff>value2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>key3</span>: <span style=color:#ae81ff>value3</span>
</span></span></code></pre></div><p>You can then create the ConfigMap using the kubectl apply command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f configmap.yaml
</span></span></code></pre></div><p>To use the ConfigMap in a pod, you can reference it using a volume mount or by using environment variables. For example, to mount the ConfigMap as a volume in a pod, you can include the following in your pod configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/etc/config</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>config-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>configMap</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-config-map</span>
</span></span></code></pre></div><p>This will mount the ConfigMap as a volume at the path /etc/config in the pod, allowing you to access the configuration data from the container.</p><p>Q18. What is a Secret in Kubernetes?</p><p>Ans. In Kubernetes, a Secret is a resource that stores sensitive information, such as passwords, API keys, or SSL certificates. Secrets are stored in an encrypted form and can be used by pods or containers in a cluster to access sensitive resources or services.</p><p>For example, you might create a Secret to store a database password that your application needs to connect to a database. To create a Secret, you can use the kubectl command and pass in the sensitive information as arguments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create secret generic db-password --from-literal<span style=color:#f92672>=</span>password<span style=color:#f92672>=</span>mysecretpassword
</span></span></code></pre></div><p>This will create a Secret called &ldquo;db-password&rdquo; with a single key-value pair, &ldquo;password&rdquo; with the value &ldquo;mysecretpassword&rdquo;.</p><p>You can also create a Secret from a file, such as an SSL certificate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl create secret tls tls-certificate --key<span style=color:#f92672>=</span>key.pem --cert<span style=color:#f92672>=</span>cert.pem
</span></span></code></pre></div><p>This will create a Secret called &ldquo;tls-certificate&rdquo; with two keys, &ldquo;tls.key&rdquo; and &ldquo;tls.crt&rdquo;, containing the contents of the key.pem and cert.pem files, respectively.</p><p>Once a Secret is created, it can be mounted as a volume in a pod or container and accessed as a file. For example, to use the &ldquo;db-password&rdquo; Secret in a pod, you can include the following in the pod&rsquo;s configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mypod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mycontainer</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>myimage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>secret-volume</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/etc/secrets</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>secret-volume</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>secret</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>secretName</span>: <span style=color:#ae81ff>db-password</span>
</span></span></code></pre></div><p>This will mount the &ldquo;db-password&rdquo; Secret as a volume in the pod and make it available at the path &ldquo;/etc/secrets&rdquo;. The application can then read the password from the file &ldquo;/etc/secrets/password&rdquo;.</p><p>Q19. What is a StatefulSet in Kubernetes?</p><p>Ans. A StatefulSet in Kubernetes is a resource that manages a set of replicated pods, similar to a Deployment. However, unlike Deployments, which are designed to be stateless and ephemeral, StatefulSets are used to manage stateful applications that require persistent storage and stable network identities.</p><p>StatefulSets provide several features that make them suitable for stateful applications:</p><p>Persistent storage: Each pod in a StatefulSet has a unique persistent volume claim (PVC) that is automatically bound to a persistent volume (PV). This ensures that the pod&rsquo;s data is preserved even if the pod is deleted or rescheduled.
Stable network identities: Each pod in a StatefulSet is given a unique, stable network identity, such as a hostname or DNS name. This makes it easier to connect to the pods and access their data.
Ordered deployment and scaling: Pods in a StatefulSet are deployed in a specific order, and can only be scaled up or down one at a time. This allows you to manage the deployment and scaling of your stateful application in a predictable manner.
To create a StatefulSet, you can use a configuration file similar to the one shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StatefulSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mysql</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>mysql:8.0</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>MYSQL_ROOT_PASSWORD</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;password&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>3306</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mysql-persistent-storage</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/lib/mysql</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>volumeClaimTemplates</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>mysql-persistent-storage</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>accessModes</span>: [ <span style=color:#e6db74>&#34;ReadWriteOnce&#34;</span> ]
</span></span><span style=display:flex><span>      <span style=color:#f92672>resources</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>requests</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>storage</span>: <span style=color:#ae81ff>5Gi</span>
</span></span></code></pre></div><p>This configuration file creates a StatefulSet with 3 replicas of a MySQL pod, each with a unique persistent volume claim and network identity. To create the StatefulSet, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f statefulset.yaml
</span></span></code></pre></div><p>This will create 3 replicas of the MySQL pod, with persistent storage and stable network identities, and manage them using the StatefulSet resource.</p><p>Q20. What is a DaemonSet in Kubernetes?</p><p>Ans. A DaemonSet in Kubernetes is a resource that ensures that a specified number of copies of a pod are running on each node in the cluster. It is used to run background or &ldquo;daemon&rdquo; processes that need to be present on every node, such as monitoring or logging agents.</p><p>For example, let&rsquo;s say you want to run a Fluentd log collection agent on every node in your cluster. You can use a DaemonSet to achieve this, as shown in the following example configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>DaemonSet</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd-daemonset</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>app</span>: <span style=color:#ae81ff>fluentd</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>fluentd</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>fluentd</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>fluentd:latest</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlog</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/log</span>
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlibdockercontainers</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/lib/docker/containers</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlog</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/var/log</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>varlibdockercontainers</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>hostPath</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/var/lib/docker/containers</span>
</span></span></code></pre></div><p>To create this DaemonSet, you can use the kubectl command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl apply -f daemonset.yaml
</span></span></code></pre></div><p>This will create a Fluentd pod on every node in the cluster, ensuring that there is always a copy of the pod running on every node. If a node goes down or is added to the cluster, the DaemonSet will automatically create or delete pods as needed to maintain the desired number of replicas.</p><h4 id=to-be-continued>To Be Continued&mldr;</h4></div></div></div></div></section></div><section class=footer id=contact><div class=footer__background_shape><svg viewBox="0 0 1920 79"><path d="M0 0h1920v79L0 0z" data-name="Path 1450"/></svg></div><div class=container><div class=row><div class=col-lg-12><div class=footer__cta><div class=shape-1><svg xmlns="http://www.w3.org/2000/svg" width="357" height="315.029" viewBox="0 0 357 315.029"><path data-name="Path 1449" d="M76.1-157.222C91.746-135.8 87.2-94.273 99.993-61.945c12.7 32.328 42.661 55.459 39.248 73.282-3.318 17.823-40.007 30.337-65.6 43.325-25.5 12.988-39.912 26.545-60.01 42.566-20.1 16.116-46.074 34.6-63.328 27.682-17.349-6.921-25.976-39.153-59.915-59.82s-93.1-29.768-105.325-51.478 22.373-56.028 43.609-93.949c21.331-37.921 29.2-79.35 53.563-96.793 24.459-17.444 65.414-10.9 103.9-6.921 38.396 3.982 74.326 5.404 89.965 26.829z" transform="translate(217.489 188.626)"/></svg></div><div class=shape-2><svg xmlns="http://www.w3.org/2000/svg" width="357" height="315.029" viewBox="0 0 357 315.029"><path data-name="Path 1449" d="M76.1-157.222C91.746-135.8 87.2-94.273 99.993-61.945c12.7 32.328 42.661 55.459 39.248 73.282-3.318 17.823-40.007 30.337-65.6 43.325-25.5 12.988-39.912 26.545-60.01 42.566-20.1 16.116-46.074 34.6-63.328 27.682-17.349-6.921-25.976-39.153-59.915-59.82s-93.1-29.768-105.325-51.478 22.373-56.028 43.609-93.949c21.331-37.921 29.2-79.35 53.563-96.793 24.459-17.444 65.414-10.9 103.9-6.921 38.396 3.982 74.326 5.404 89.965 26.829z" transform="translate(217.489 188.626)"/></svg></div><div class="text-light footer__cta_content"><span>Contact me</span><h2 class=mb-0>Lets Start a Project</h2></div><div class=footer__cta_action><a class="btn btn-light btn-zoom" href=https://AceTheOps.com/contact>Get in
touch</a></div></div></div></div><div class="row footer__widget"><div class=col-lg-4><div class="footer__widget_logo mb-5"><img src=https://AceTheOps.com/images/contact/widget-logo.png style=width:400px alt=widget-logo></div></div><div class=col-lg-4 style=margin-left:100px><div class="text-light footer__widget_address mb-5"><h4 class=base-font>Sitemap</h4><ul class="unstyle-list small"><li class=mb-2><a class=text-light href=https://AceTheOps.com/about>About me</a></li><li class=mb-2><a class=text-light href=https://AceTheOps.com/>Frequently Ask Question</a></li><li class=mb-2><a class=text-light href=https://AceTheOps.com/>Privacy & Policy</a></li><li class=mb-2><a class=text-light href=https://AceTheOps.com/>Latest Article</a></li></ul><h4 class=base-font>Address</h4><ul class="fa-ul small"><li class=mb-2><a class=text-light href=tel:><span class=fa-li><i class="fa fa-phone"></i></span></a></li><li class=mb-2><a class=text-light href=mailto:aakriti@acetheops.com><span class=fa-li><i class="fa fa-envelope"></i></span>aakriti@acetheops.com</a></li><li class=mb-2><span class=fa-li><i class="fa fa-map-marker"></i></span>23 Khan Niketon, Grand Street, NYK.</a></li></ul></div></div></div><div class="row footer__footer"><div class=col-lg-6><div class="footer__footer_copy text-light"><p>Copyright 2023 - All Rights Reserved by <a class=text-light href=https://AceTheOps.com/ target=_blank>AceTheOps</a></p></div></div><div class=col-lg-6><div class=footer__footer_social><ul class=unstyle-list><li class="d-inline-block mx-2"><a class=text-light target=_blank href=https://www.facebook.com/><i class="fa fa-facebook-official"></i></a></li><li class="d-inline-block mx-2"><a class=text-light target=_blank href=https://www.linkedin.com/><i class="fa fa-linkedin-square"></i></a></li><li class="d-inline-block mx-2"><a class=text-light target=_blank href=https://www.pinterest.com/><i class="fa fa-pinterest-square"></i></a></li><li class="d-inline-block mx-2"><a class=text-light target=_blank href=https://twitter.com/><i class="fa fa-twitter-square"></i></a></li></ul></div></div></div></div></section><script src="https://maps.googleapis.com/maps/api/js?key=YOUR%20GOOGLE%20MAP%20API&libraries=geometry"></script>
<script src=https://AceTheOps.com/plugins/jQuery/jquery.min.js></script>
<script src=https://AceTheOps.com/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://AceTheOps.com/plugins/slick/slick.min.js></script>
<script src=https://AceTheOps.com/plugins/waypoint/jquery.waypoints.min.js></script>
<script src=https://AceTheOps.com/plugins/magnafic-popup/jquery.magnific-popup.min.js></script>
<script src=https://AceTheOps.com/plugins/tweenmax/TweenMax.min.js></script>
<script src=https://AceTheOps.com/plugins/imagesloaded/imagesloaded.min.js></script>
<script src=https://AceTheOps.com/plugins/masonry/masonry.min.js></script>
<script src=https://AceTheOps.com/js/script.min.js></script></body></html>